---
/**
 * AnimatedBackground Component
 * 
 * Fondo animado tipo red 3D con puntos brillantes
 * - Basado en la imagen de referencia (fondo.png)
 * - Puntos luminosos esparcidos con efecto glow
 * - Líneas de conexión tenues
 * - Movimiento orgánico y flotante
 * - Totalmente responsive
 */
---

<div class="animated-background">
  <canvas id="networkCanvas"></canvas>
</div>

<style>
  .animated-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    overflow: hidden;
    /* Fondo suave con gradientes rosa/rojizo muy tenues */
    background: 
      radial-gradient(ellipse 100% 80% at 50% 0%, rgba(230, 100, 120, 0.08) 0%, transparent 60%),
      radial-gradient(ellipse 80% 100% at 100% 100%, rgba(180, 80, 100, 0.06) 0%, transparent 70%),
      radial-gradient(ellipse 100% 100% at 0% 50%, rgba(200, 100, 140, 0.04) 0%, transparent 80%),
      linear-gradient(135deg, #0a0e27 0%, #1a1530 50%, #140d25 100%);
    background-attachment: fixed;
  }

  /* Overlay muy suave para darle profundidad sin sobrecargar */
  .animated-background::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
      radial-gradient(circle at 50% 50%, rgba(220, 120, 140, 0.05) 0%, transparent 40%),
      radial-gradient(circle at 80% 20%, rgba(200, 100, 130, 0.03) 0%, transparent 50%);
    pointer-events: none;
  }

  canvas {
    display: block;
    width: 100%;
    height: 100%;
    position: relative;
    z-index: 1;
    opacity: 0.6;
  }

  @media (prefers-reduced-motion: reduce) {
    canvas {
      opacity: 0.3;
    }

    .animated-background::before {
      display: none;
    }
  }
</style>

<script>
  interface Particle {
    x: number;
    y: number;
    z: number;
    vx: number;
    vy: number;
    vz: number;
    radius: number;
    brightness: number;
    targetBrightness: number;
    pulseSpeed: number;
  }

   class NetworkBackground {
    canvas: HTMLCanvasElement;
    ctx: CanvasRenderingContext2D;
    particles: Particle[] = [];
    particleCount: number = 50;
    connectionDistance: number = 120;
    time: number = 0;
    animationId: number | null = null;

    constructor() {
      this.canvas = document.getElementById('networkCanvas') as HTMLCanvasElement;
      this.ctx = this.canvas.getContext('2d')!;
      this.setupCanvas();
      this.createParticles();
      this.animate();
      window.addEventListener('resize', () => this.setupCanvas());
    }

    setupCanvas(): void {
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
    }

     createParticles(): void {
       this.particles = [];
       for (let i = 0; i < this.particleCount; i++) {
         this.particles.push({
           x: Math.random() * this.canvas.width,
           y: Math.random() * this.canvas.height,
           z: Math.random() * 1000,
           vx: (Math.random() - 0.5) * 0.3,
           vy: (Math.random() - 0.5) * 0.3,
           vz: (Math.random() - 0.5) * 0.15,
           radius: Math.random() * 2.5 + 1,
           brightness: Math.random() * 0.4 + 0.2,
           targetBrightness: Math.random() * 0.4 + 0.2,
           pulseSpeed: Math.random() * 0.01 + 0.005
         });
       }
     }

    updateParticles(): void {
      for (let particle of this.particles) {
        // Movimiento
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.z += particle.vz;

        // Rebote en los bordes
        if (particle.x < 0 || particle.x > this.canvas.width) particle.vx *= -1;
        if (particle.y < 0 || particle.y > this.canvas.height) particle.vy *= -1;
        if (particle.z < 100 || particle.z > 1100) particle.vz *= -1;

        // Mantener dentro de los límites
        particle.x = Math.max(0, Math.min(this.canvas.width, particle.x));
        particle.y = Math.max(0, Math.min(this.canvas.height, particle.y));
        particle.z = Math.max(100, Math.min(1100, particle.z));

        // Pulso de brillo
        particle.brightness += (particle.targetBrightness - particle.brightness) * particle.pulseSpeed;
        
        if (Math.abs(particle.brightness - particle.targetBrightness) < 0.01) {
          particle.targetBrightness = Math.random() * 0.6 + 0.2;
        }
      }
    }

     drawParticles(): void {
       for (let particle of this.particles) {
         // Escala basada en Z (perspectiva)
         const scale = (particle.z - 100) / 1000;
         const displayRadius = particle.radius * (0.5 + scale * 0.5);

         // Brillo suave
         const brightness = particle.brightness * (0.5 + scale * 0.5);

         // Círculo principal con gradiente rosa/rojo suave
         const gradient = this.ctx.createRadialGradient(
           particle.x, particle.y, 0,
           particle.x, particle.y, displayRadius * 2
         );

         // Colores rosa/rojo muy tenues y agradables
         gradient.addColorStop(0, `rgba(230, 120, 140, ${brightness * 0.5})`);
         gradient.addColorStop(0.5, `rgba(200, 100, 130, ${brightness * 0.2})`);
         gradient.addColorStop(1, `rgba(200, 100, 130, 0)`);

         this.ctx.fillStyle = gradient;
         this.ctx.fillRect(
           particle.x - displayRadius * 2,
           particle.y - displayRadius * 2,
           displayRadius * 4,
           displayRadius * 4
         );

         // Círculo sólido en el centro muy sutil
         this.ctx.fillStyle = `rgba(220, 110, 135, ${brightness * 0.6})`;
         this.ctx.beginPath();
         this.ctx.arc(particle.x, particle.y, displayRadius * 0.5, 0, Math.PI * 2);
         this.ctx.fill();
       }
     }

     drawConnections(): void {
       this.ctx.lineWidth = 0.6;

       for (let i = 0; i < this.particles.length; i++) {
         for (let j = i + 1; j < this.particles.length; j++) {
           const p1 = this.particles[i];
           const p2 = this.particles[j];

           const dx = p2.x - p1.x;
           const dy = p2.y - p1.y;
           const distance = Math.sqrt(dx * dx + dy * dy);

           if (distance < this.connectionDistance) {
             const opacity = 1 - distance / this.connectionDistance;
             // Rosa/rojo muy tenue para las líneas
             this.ctx.strokeStyle = `rgba(220, 120, 140, ${opacity * 0.15})`;
             this.ctx.beginPath();
             this.ctx.moveTo(p1.x, p1.y);
             this.ctx.lineTo(p2.x, p2.y);
             this.ctx.stroke();
           }
         }
       }
     }

     animate = (): void => {
       // Limpiar canvas muy sutilmente para mantener fade suave
       this.ctx.fillStyle = 'rgba(10, 14, 39, 0.02)';
       this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

       this.updateParticles();
       this.drawConnections();
       this.drawParticles();

       this.time++;
       this.animationId = requestAnimationFrame(this.animate);
     };

    destroy(): void {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
    }
  }

  // Inicializar cuando el DOM esté listo
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      new NetworkBackground();
    });
  } else {
    new NetworkBackground();
  }
</script>
