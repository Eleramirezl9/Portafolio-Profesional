---
/**
 * AnimatedBackground Component
 * 
 * Fondo animado tipo red 3D con puntos brillantes
 * - Basado en la imagen de referencia (fondo.png)
 * - Puntos luminosos esparcidos con efecto glow
 * - Líneas de conexión tenues
 * - Movimiento orgánico y flotante
 * - Totalmente responsive
 */
---

<div class="animated-background">
  <canvas id="networkCanvas"></canvas>
</div>

<style>
  .animated-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    overflow: hidden;
    background: linear-gradient(135deg, #0a1428 0%, #0f1b2e 50%, #1a2847 100%);
  }

  canvas {
    display: block;
    width: 100%;
    height: 100%;
  }

  @media (prefers-reduced-motion: reduce) {
    canvas {
      opacity: 1;
    }
  }
</style>

<script>
  interface Particle {
    x: number;
    y: number;
    z: number;
    vx: number;
    vy: number;
    vz: number;
    radius: number;
    brightness: number;
    targetBrightness: number;
    pulseSpeed: number;
  }

  class NetworkBackground {
    canvas: HTMLCanvasElement;
    ctx: CanvasRenderingContext2D;
    particles: Particle[] = [];
    particleCount: number = 120;
    connectionDistance: number = 150;
    time: number = 0;
    animationId: number | null = null;

    constructor() {
      this.canvas = document.getElementById('networkCanvas') as HTMLCanvasElement;
      this.ctx = this.canvas.getContext('2d')!;
      this.setupCanvas();
      this.createParticles();
      this.animate();
      window.addEventListener('resize', () => this.setupCanvas());
    }

    setupCanvas(): void {
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
    }

    createParticles(): void {
      this.particles = [];
      for (let i = 0; i < this.particleCount; i++) {
        this.particles.push({
          x: Math.random() * this.canvas.width,
          y: Math.random() * this.canvas.height,
          z: Math.random() * 1000,
          vx: (Math.random() - 0.5) * 0.5,
          vy: (Math.random() - 0.5) * 0.5,
          vz: (Math.random() - 0.5) * 0.3,
          radius: Math.random() * 4 + 2,
          brightness: Math.random() * 0.5 + 0.3,
          targetBrightness: Math.random() * 0.5 + 0.3,
          pulseSpeed: Math.random() * 0.02 + 0.01
        });
      }
    }

    updateParticles(): void {
      for (let particle of this.particles) {
        // Movimiento
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.z += particle.vz;

        // Rebote en los bordes
        if (particle.x < 0 || particle.x > this.canvas.width) particle.vx *= -1;
        if (particle.y < 0 || particle.y > this.canvas.height) particle.vy *= -1;
        if (particle.z < 100 || particle.z > 1100) particle.vz *= -1;

        // Mantener dentro de los límites
        particle.x = Math.max(0, Math.min(this.canvas.width, particle.x));
        particle.y = Math.max(0, Math.min(this.canvas.height, particle.y));
        particle.z = Math.max(100, Math.min(1100, particle.z));

        // Pulso de brillo
        particle.brightness += (particle.targetBrightness - particle.brightness) * particle.pulseSpeed;
        
        if (Math.abs(particle.brightness - particle.targetBrightness) < 0.01) {
          particle.targetBrightness = Math.random() * 0.6 + 0.2;
        }
      }
    }

    drawParticles(): void {
      for (let particle of this.particles) {
        // Escala basada en Z (perspectiva)
        const scale = (particle.z - 100) / 1000;
        const displayRadius = particle.radius * (0.5 + scale * 0.5);

        // Brillo
        const brightness = particle.brightness * (0.5 + scale * 0.5);

        // Círculo principal (más brillante)
        const gradient = this.ctx.createRadialGradient(
          particle.x, particle.y, 0,
          particle.x, particle.y, displayRadius * 2
        );

        gradient.addColorStop(0, `rgba(255, 100, 150, ${brightness * 0.8})`);
        gradient.addColorStop(0.5, `rgba(255, 100, 150, ${brightness * 0.4})`);
        gradient.addColorStop(1, `rgba(255, 100, 150, 0)`);

        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(
          particle.x - displayRadius * 2,
          particle.y - displayRadius * 2,
          displayRadius * 4,
          displayRadius * 4
        );

        // Círculo sólido en el centro
        this.ctx.fillStyle = `rgba(255, 150, 100, ${brightness})`;
        this.ctx.beginPath();
        this.ctx.arc(particle.x, particle.y, displayRadius, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }

    drawConnections(): void {
      this.ctx.strokeStyle = 'rgba(100, 200, 255, 0.15)';
      this.ctx.lineWidth = 1;

      for (let i = 0; i < this.particles.length; i++) {
        for (let j = i + 1; j < this.particles.length; j++) {
          const p1 = this.particles[i];
          const p2 = this.particles[j];

          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < this.connectionDistance) {
            const opacity = 1 - distance / this.connectionDistance;
            this.ctx.strokeStyle = `rgba(100, 200, 255, ${opacity * 0.2})`;
            this.ctx.beginPath();
            this.ctx.moveTo(p1.x, p1.y);
            this.ctx.lineTo(p2.x, p2.y);
            this.ctx.stroke();
          }
        }
      }
    }

    animate = (): void => {
      // Limpiar canvas
      this.ctx.fillStyle = 'rgba(10, 20, 40, 0.05)';
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

      this.updateParticles();
      this.drawConnections();
      this.drawParticles();

      this.time++;
      this.animationId = requestAnimationFrame(this.animate);
    };

    destroy(): void {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
    }
  }

  // Inicializar cuando el DOM esté listo
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      new NetworkBackground();
    });
  } else {
    new NetworkBackground();
  }
</script>
